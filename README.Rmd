---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# strapgod

<p align="center">
  <img src="./man/figures/strap-god.jpg">
</p>

## Introduction

The goal of strapgod is to create _virtual groups_ on top of a `tibble` or 
`grouped_df` that function as resamples of the rows of the data frame. You can
then perform a `summarise()`, `do()`, or use `group_map()` on this 
`resampled_df` to perform an efficient resampled / bootstrapped calculation.

## Installation

You can install the released version of strapgod from [CRAN](https://CRAN.R-project.org) with:

``` r
# no you cannot
install.packages("strapgod")
```

Install from github with:

``` r
devtools::install_github("DavisVaughan/strapgod")
```

## Example

Note how creating a `resampled_df` does not add a new column, or new rows,
but the groups are modified.

```{r}
library(strapgod)
library(dplyr)
set.seed(123)

iris %>%
  bootstrapify(10)
```

You can feed a `resampled_df` into `summarise()` or `do()` to perform
efficient bootstrapped computations.

```{r}
iris %>%
  bootstrapify(10) %>%
  summarise(per_strap_mean = mean(Petal.Width))
```

The data can be grouped as well.

```{r}
iris %>%
  group_by(Species) %>%
  bootstrapify(10) %>%
  summarise(per_strap_species_mean = mean(Petal.Width))
```

## Materializing bootstraps

`dplyr::collect()` can be used to make the implicit virtual groups explicit.

```{r}
iris %>%
  group_by(Species) %>%
  bootstrapify(10) %>%
  collect()
```

You can specify an `id` column to get an in-bootstrap sequence from `1:n`. You 
can also specify an `original_id` column to retrieve the original row that 
the bootstrapped row came from.

```{r}
iris %>%
  group_by(Species) %>%
  bootstrapify(10) %>%
  collect(id = ".id", original_id = ".original_id")
```

## `samplify()`

For general sampling, use `samplify()`.

```{r}
iris %>%
  samplify(times = 5, size = 10, replace = FALSE)
```

Be careful not to specify a size larger than one of your groups! This will throw
an error.

```{r, error=TRUE}
iris_50_5_group_sizes <- iris[1:55,] %>%
  group_by(Species) %>%
  group_trim()

count(iris_50_5_group_sizes, Species)

# size = 10 > min_group_size = 5
iris_50_5_group_sizes %>%
  samplify(times = 2, size = 10)
```


## `group_*()` Functions

`dplyr 0.8` adds some more neat group-wise functionality. 

Here is a full walkthrough of some of the ways you can use `bootstrapify()`,
using a modified version of the examples in [this rsample issue](https://github.com/tidymodels/rsample/issues/52).

```{r}
suppressPackageStartupMessages({
  library(strapgod)
  library(dplyr)
  library(broom)
  library(ggplot2)
  library(purrr)
  library(tidyr)
})
```

### Tidying bootstrapped models 

```{r}
# without bootstraps
iris %>%
  group_by(Species) %>%
  group_map(~tidy(lm(Sepal.Length ~ Petal.Length, data = .x)))

# with bootstraps
iris %>%
  group_by(Species) %>%
  bootstrapify(10) %>%
  group_map(~tidy(lm(Sepal.Length ~ Petal.Length, data = .x)))
```

### Plotting bootstrapped results

```{r bootstrap-plots}
# without bootstrap
mtcars %>%
  ggplot(aes(hp, mpg)) + 
  geom_smooth(se = FALSE)

# with bootstrap
mtcars %>%
  bootstrapify(10) %>%
  collect() %>%
  ggplot(aes(hp, mpg, group = .bootstrap)) + 
  geom_smooth(se = FALSE)

```

### "Multiple models" workflow

```{r}
# The nest+mutate+unnest combo
iris %>% 
  group_by(Species) %>%
  bootstrapify(10) %>%
  group_nest() %>%
  mutate(
    model = map(data, ~lm(Sepal.Length ~ Petal.Length, data = .x)),
    coef = map(model, tidy)
  ) %>%
  unnest(coef)

# Using rap  
library(rap)

iris %>% 
  group_by(Species) %>%
  bootstrapify(10) %>%
  group_nest() %>%
  # cleaner than mutate+map
  rap(
    model = ~lm(Sepal.Length ~ Petal.Length, data = data),
    coef  = ~tidy(model)
  ) %>%
  unnest(coef)
```

